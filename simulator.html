<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Mini Assembly Simulator</title>
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    body {
      font-family: monospace;
      background: #222;
      color: #eee;
      margin: 0;
      padding: 0;
    }
    #root {
      max-width: 480px;
      margin: 0 auto;
      padding: 8px;
    }
    .container {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    textarea, input[type="text"], input[type="number"] {
      width: 100%;
      font-family: monospace;
      font-size: 1em;
      background: #333;
      color: #eee;
      border: 1px solid #555;
      border-radius: 4px;
      padding: 4px;
      box-sizing: border-box;
    }
    .section {
      background: #292929;
      padding: 8px;
      border-radius: 6px;
      box-shadow: 0 0 4px #1116;
      margin-bottom: 4px;
    }
    .label {
      font-weight: bold;
      margin-bottom: 4px;
      color: #aef;
    }
    .row {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
      margin-bottom: 4px;
    }
    .memory-view {
      display: flex;
      flex-wrap: wrap;
      gap: 2px;
    }
    .memcell {
      width: 28px;
      text-align: center;
      background: #333;
      border: 1px solid #444;
      border-radius: 2px;
      font-size: 0.95em;
      margin-bottom: 2px;
      color: #eaeaea;
    }
    .memcell input {
      width: 24px;
      background: #444;
      color: #eee;
      border: none;
      text-align: center;
    }
    .stack-view {
      display: flex;
      flex-direction: column-reverse;
      gap: 2px;
    }
    .stackcell {
      background: #444;
      border: 1px solid #666;
      border-radius: 2px;
      padding: 2px 8px;
      font-size: 0.95em;
      color: #fafafa;
    }
    .editor-highlight {
      background: #373;
      color: #fff;
      font-weight: bold;
    }
    .error {
      color: #faa;
      font-weight: bold;
      margin-top: 4px;
    }
    button {
      background: #334;
      color: #fff;
      border: none;
      border-radius: 3px;
      padding: 6px 12px;
      margin: 2px 0;
      font-size: 1em;
      cursor: pointer;
    }
    button:disabled {
      background: #222;
      color: #888;
      cursor: not-allowed;
    }
    @media (max-width: 500px) {
      #root {
        max-width: 100vw;
        padding: 2px;
      }
      .container {
        gap: 4px;
      }
      .section {
        padding: 4px;
      }
      .memcell {
        width: 24px;
        font-size: 0.9em;
      }
      .stackcell {
        font-size: 0.9em;
        padding: 1px 4px;
      }
      button {
        font-size: 0.95em;
        padding: 5px 10px;
      }
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">

const REG_NAMES = ["R0", "R1", "R2", "R3"];
const INIT_REGS = { R0: 0, R1: 0, R2: 0, R3: 0, FLAG: 0 };
const INIT_MEM = Array(100).fill(0);

function parseProgram(code) {
  // Remove comments, parse labels, split instructions
  let lines = code.split('\n').map(l => l.replace(/;.*/,'').trim());
  let labels = {};
  let instructions = [];
  for (let i=0; i<lines.length; ++i) {
    let line = lines[i];
    if (!line) continue;
    if (/^[\w\d_]+:$/.test(line)) {
      labels[line.replace(':','')] = instructions.length;
      continue;
    }
    instructions.push({raw:line, lineNumber:i});
  }
  return {instructions, labels};
}

function evalCmp(a, b) {
  if (a < b) return -1;
  else if (a > b) return 1;
  else return 0;
}

// Main Simulator
function Simulator() {
  // Editor state
  const [code, setCode] = React.useState(
`start:
  mov R0 10 ; set R0 to 10
  mov R1 0
loop:
  cmp R0 R1
  je end
  push R0
  mov [20+R1] R0
  mov R2 [20+R1]
  pop R3
  mov R1 R1+1
  jmp loop
end:
  halt
`);
  // Parsed program
  const [program, setProgram] = React.useState(parseProgram(code));

  // Machine state
  const [registers, setRegisters] = React.useState({...INIT_REGS});
  const [memory, setMemory] = React.useState([...INIT_MEM]);
  const [stack, setStack] = React.useState([]);
  const [pc, setPC] = React.useState(0);
  const [halted, setHalted] = React.useState(false);
  const [error, setError] = React.useState("");
  const [editMode, setEditMode] = React.useState(true);
  const [highlightLine, setHighlightLine] = React.useState(null);

  // For editing before run
  const handleRegEdit = (reg, val) => {
    let v = Number(val) || 0;
    setRegisters(r => ({...r, [reg]:v}));
  };
  const handleMemEdit = (idx, val) => {
    let v = Number(val) || 0;
    setMemory(m => {
      let copy = [...m];
      copy[idx] = v;
      return copy;
    });
  };

  // Re-parse on code change
  React.useEffect(() => {
    setProgram(parseProgram(code));
  }, [code]);

  // Start/Reset
  const handleReset = () => {
    setRegisters({...INIT_REGS});
    setMemory([...INIT_MEM]);
    setStack([]);
    setPC(0);
    setHalted(false);
    setError("");
    setEditMode(true);
    setHighlightLine(null);
  };

  // Run (step-by-step)
  const handleStep = () => {
    if (halted || pc >= program.instructions.length) return;
    setError("");
    let instr = program.instructions[pc].raw;
    setHighlightLine(program.instructions[pc].lineNumber);

    // Parse instruction
    let words = instr.split(/\s+/);
    let op = words[0].toLowerCase();

    let nextPC = pc + 1;
    let regCopy = {...registers};
    let memCopy = [...memory];
    let stackCopy = [...stack];
    let err = "";

    // Helper: get register or value
    const getVal = v => {
      if (REG_NAMES.includes(v)) return regCopy[v];
      if (/^\d+$/.test(v)) return parseInt(v);
      if (/^R\d\+\d+$/.test(v)) { // e.g. R1+1
        let [r, add] = v.split('+');
        return (regCopy[r]||0) + parseInt(add);
      }
      err = `Invalid value: ${v}`;
      return 0;
    };

    // Helper: get address [base+Rx]
    const parseAddr = expr => {
      let m = expr.match(/^(\d+)\+([Rr]\d)$/);
      if (!m) return null;
      let base = parseInt(m[1]);
      let reg = m[2].toUpperCase();
      if (!REG_NAMES.includes(reg)) return null;
      let addr = base + regCopy[reg];
      if (addr < 0 || addr >= 100) {
        err = `Memory address out of bounds: ${addr}`;
        return null;
      }
      return addr;
    };

    // Execute instruction
    try {
      switch(op) {
        case 'mov': {
          // mov <target> <source>
          // mov Ry [base+Rx] / mov [base+Rx] Ry
          if (REG_NAMES.includes(words[1]) && REG_NAMES.includes(words[2])) {
            regCopy[words[1]] = regCopy[words[2]];
          } else if (REG_NAMES.includes(words[1]) && /^\d+$/.test(words[2])) {
            regCopy[words[1]] = parseInt(words[2]);
          } else if (REG_NAMES.includes(words[1]) && /^R\d\+\d+$/.test(words[2])) {
            regCopy[words[1]] = getVal(words[2]);
          } else if (REG_NAMES.includes(words[1]) && /^\[\d+\+[Rr]\d\]$/.test(words[2])) {
            let addr = parseAddr(words[2].slice(1,-1));
            if (addr!==null) regCopy[words[1]] = memCopy[addr];
          } else if (/^\[\d+\+[Rr]\d\]$/.test(words[1]) && REG_NAMES.includes(words[2])) {
            let addr = parseAddr(words[1].slice(1,-1));
            if (addr!==null) memCopy[addr] = regCopy[words[2]];
          } else {
            err = `Invalid mov syntax: ${instr}`;
          }
          break;
        }
        case 'cmp': {
          if (REG_NAMES.includes(words[1]) && /^\d+$/.test(words[2])) {
            regCopy.FLAG = evalCmp(regCopy[words[1]], parseInt(words[2]));
          } else if (REG_NAMES.includes(words[1]) && REG_NAMES.includes(words[2])) {
            regCopy.FLAG = evalCmp(regCopy[words[1]], regCopy[words[2]]);
          } else {
            err = `Invalid cmp syntax: ${instr}`;
          }
          break;
        }
        case 'jmp': {
          let lbl = words[1];
          if (program.labels.hasOwnProperty(lbl)) {
            nextPC = program.labels[lbl];
          } else {
            err = `Label not found: ${lbl}`;
          }
          break;
        }
        case 'je': {
          if (regCopy.FLAG === 0) {
            let lbl = words[1];
            if (program.labels.hasOwnProperty(lbl)) {
              nextPC = program.labels[lbl];
            } else {
              err = `Label not found: ${lbl}`;
            }
          }
          break;
        }
        case 'jne': {
          if (regCopy.FLAG !== 0) {
            let lbl = words[1];
            if (program.labels.hasOwnProperty(lbl)) {
              nextPC = program.labels[lbl];
            } else {
              err = `Label not found: ${lbl}`;
            }
          }
          break;
        }
        case 'jg': {
          if (regCopy.FLAG === 1) {
            let lbl = words[1];
            if (program.labels.hasOwnProperty(lbl)) {
              nextPC = program.labels[lbl];
            } else {
              err = `Label not found: ${lbl}`;
            }
          }
          break;
        }
        case 'jge': {
          if (regCopy.FLAG === 0 || regCopy.FLAG === 1) {
            let lbl = words[1];
            if (program.labels.hasOwnProperty(lbl)) {
              nextPC = program.labels[lbl];
            } else {
              err = `Label not found: ${lbl}`;
            }
          }
          break;
        }
        case 'jl': {
          if (regCopy.FLAG === -1) {
            let lbl = words[1];
            if (program.labels.hasOwnProperty(lbl)) {
              nextPC = program.labels[lbl];
            } else {
              err = `Label not found: ${lbl}`;
            }
          }
          break;
        }
        case 'jle': {
          if (regCopy.FLAG === 0 || regCopy.FLAG === -1) {
            let lbl = words[1];
            if (program.labels.hasOwnProperty(lbl)) {
              nextPC = program.labels[lbl];
            } else {
              err = `Label not found: ${lbl}`;
            }
          }
          break;
        }
        case 'push': {
          if (REG_NAMES.includes(words[1])) {
            stackCopy.push(regCopy[words[1]]);
          } else {
            err = `Invalid push syntax: ${instr}`;
          }
          break;
        }
        case 'pop': {
          if (REG_NAMES.includes(words[1])) {
            if (stackCopy.length === 0) {
              err = `Stack underflow`;
            } else {
              regCopy[words[1]] = stackCopy.pop();
            }
          } else {
            err = `Invalid pop syntax: ${instr}`;
          }
          break;
        }
        case 'halt': {
          setHalted(true);
          break;
        }
        default:
          err = `Unknown instruction: ${op}`;
      }
    } catch(e) {
      err = "Runtime error: " + e.message;
    }

    // Set states
    if (err) {
      setError(err);
      setHalted(true);
      return;
    }
    setRegisters(regCopy);
    setMemory(memCopy);
    setStack(stackCopy);
    setPC(nextPC);

    // End if halt or out of instructions
    if (nextPC >= program.instructions.length) setHalted(true);
    setEditMode(false);
  };

  // UI
  return (
    <div className="container">
      <div className="section">
        <div className="label">Assembly Editor</div>
        <textarea
          rows={8}
          value={code}
          disabled={!editMode}
          onChange={e => setCode(e.target.value)}
          style={{resize:'vertical'}}
        />
        {editMode && (
          <div style={{fontSize:"0.9em",color:"#ccc",marginTop:2}}>
            You can edit code, registers, and memory before running.
          </div>
        )}
      </div>
      <div className="section">
        <div className="label">Registers</div>
        <div className="row">
          {REG_NAMES.map(r =>
            <div key={r}>
              {r}: {editMode ?
                <input
                  type="number"
                  value={registers[r]}
                  onChange={e=>handleRegEdit(r,e.target.value)}
                  style={{width:"50px"}}
                /> :
                <span style={{fontWeight:"bold"}}>{registers[r]}</span>
              }
            </div>
          )}
          <div>
            FLAG: <span style={{fontWeight:"bold"}}>{registers.FLAG}</span>
          </div>
        </div>
      </div>
      <div className="section">
        <div className="label">Memory (100 bytes)</div>
        <div className="memory-view">
          {memory.map((v,i)=>
            <div className="memcell" key={i}>
              {editMode ?
                <input
                  type="number"
                  value={v}
                  onChange={e=>handleMemEdit(i,e.target.value)}
                  style={{width:"20px"}}
                />:
                <span>{v}</span>
              }
            </div>
          )}
        </div>
        <div style={{fontSize:"0.8em",color:"#aaa"}}>Addresses: 0 – 99</div>
      </div>
      <div className="section">
        <div className="label">Stack</div>
        <div className="stack-view">
          {stack.length === 0 && <div style={{color:"#888"}}>(empty)</div>}
          {stack.map((v,i)=>
            <div className="stackcell" key={i}>{v}</div>
          )}
        </div>
      </div>
      <div className="section">
        <div className="label">Step Execution</div>
        <div>
          <button onClick={handleStep} disabled={halted}>Next Step</button>
          <button onClick={handleReset}>Reset</button>
        </div>
        <div style={{marginTop:4}}>
          <span>PC: {pc} </span>
          {halted && <span style={{color:"#ff7878"}}>HALTED</span>}
        </div>
        {error && <div className="error">Error: {error}</div>}
      </div>
      <div className="section">
        <div className="label">Program Listing</div>
        <div style={{fontSize:"0.95em",whiteSpace:"pre-wrap"}}>
        {code.split('\n').map((line,i)=>
          <div
            key={i}
            className={highlightLine===i ? "editor-highlight" : ""}
            style={{
              background:highlightLine===i?'#373':'none',
              color:highlightLine===i?'#fff':'inherit',
              borderRadius:'2px',
              padding:"0 2px"
            }}>
            {i+1}: {line}
          </div>
        )}
        </div>
      </div>
      <div style={{fontSize:"0.9em",color:"#aaa",marginTop:8}}>
        <b>Instructions:</b> mov, cmp, jmp, je, jne, jg, jge, jl, jle, push, pop, halt<br/>
        Registers: R0–R3, FLAG (-1/0/1)<br/>
        Memory: 100 bytes, addresses 0–99<br/>
        Stack: separate from memory<br/>
        Comments: use <code>;</code>
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<Simulator />);
  </script>
</body>
</html>

